# Drop integration

Drop protocol can be integrated into external UI or DeFi on Neutron or any other IBC-connected chain. This page describes possible approaches of doing that.

## Overview

It is possible to integrate the Drop protocol in several ways:

1. Use the auto-generated TypeScript client for smart contracts to interact with the Drop protocol.
2. Craft the Drop messages manually and send them to Neutron chain or other supported chains to stake from it using the ibc-hooks or Skip API.
3. (WIP) Use the Drop protocol through the Skip API.

Integration with Drop generally consists of 3 actions and several queries.

Actions are:

- staking
- unstaking request
- unstaking withdrawal

Queries are:

- instance contracts discovery
- dASSET denom
- dASSET balance
- exchange rate
- unstacking request status

### Using TypeScript clients

In case if one is interested in direct interaction with contracts on Neutron chain, you can use the generated TypeScript clients for smart contracts.
They allow to make staking and unstaking with the assets that are already on the Neutron chain.

All contract methods are covered in autogenerated code using https://github.com/neutron-org/contracts2ts tool. You can find examples of generated code in the https://github.com/hadronlabs-org/drop-contracts/tree/main/integration_tests/src/generated/contractLib repo.

This code is generated using https://github.com/hadronlabs-org/drop-contracts/blob/main/integration_tests/src/rebuild-client.ts configuration.

### Crafting messages manually

Use the messages templates provided in this doc to send them directly to the contracts.
This is especially useful in the case of issuing a transaction from another chain.
For example, ATOM staking can be done in a single IBC-transfer that calls Drop contract via [ibc-hooks module on Neutron](https://docs.neutron.org/neutron/modules/3rdparty/osmosis/ibc-hooks/overview).

> It must be noted that the approach described here results in dASSET minting on Neutron.
> It means that after staking with Drop, the user have to do the next action with LST from Neutron chain.

To simplify the work one still can use SkipAPI. The process is as follows:

- https://api-docs.skip.money/reference/getassets endpoint allows getting proper denom of a specific asset on a specific chain
- https://api-docs.skip.money/reference/getroutev2 endpoint allows building a proper route to transfer an asset to Neutron
- https://api-docs.skip.money/reference/getmsgsv2 endpoint allows building a message to be issued on the target chain to stake assets with Drop. To do that, one should specify the contract address and message needed in the `post_route_handler` section (`COSMWASMCONTRACTMSGWRAPPER`).

Here are the examples for staking transactions:

#### Staking ATOM from Cosmos Hub

Cosmos Hub transaction message:

```json
{
  "type": "cosmos-sdk/MsgTransfer",
  "value": {
    "memo": "{\"wasm\":{\"contract\":\"neutron15lp29w5vtntsgecwxp5qx0m7tka6km885pcls4e4ule6yz6dhvqstukrvu\",\"msg\":{\"bond\":{\"receiver\":\"neutron1vlw72wh7rvl2vg4w434a6h9mftsl5vfqzntwdh\"}}}}",
    "receiver": "neutron15lp29w5vtntsgecwxp5qx0m7tka6km885pcls4e4ule6yz6dhvqstukrvu",
    "sender": "cosmos1vlw72wh7rvl2vg4w434a6h9mftsl5vfqxvzvhs",
    "source_channel": "channel-569",
    "source_port": "transfer",
    "timeout_height": {},
    "timeout_timestamp": "1715100002194956544",
    "token": {
      "amount": "200000",
      "denom": "uatom"
    }
  }
}
```

Cosmos Hub transaction memo:

```json
{
  "wasm": {
    "contract": "neutron15lp29w5vtntsgecwxp5qx0m7tka6km885pcls4e4ule6yz6dhvqstukrvu",
    "msg": {
      "bond": {
        "receiver": "neutron1vlw72wh7rvl2vg4w434a6h9mftsl5vfqzntwdh"
      }
    }
  }
}
```

#### Staking ATOM from Osmosis

Osmosis transaction message:

```json
{
  "type": "cosmos-sdk/MsgTransfer",
  "value": {
    "memo": "{\"forward\":{\"channel\":\"channel-569\",\"next\":{\"wasm\":{\"contract\":\"neutron15lp29w5vtntsgecwxp5qx0m7tka6km885pcls4e4ule6yz6dhvqstukrvu\",\"msg\":{\"bond\":{\"receiver\":\"neutron1vlw72wh7rvl2vg4w434a6h9mftsl5vfqzntwdh\"}}}},\"port\":\"transfer\",\"receiver\":\"neutron15lp29w5vtntsgecwxp5qx0m7tka6km885pcls4e4ule6yz6dhvqstukrvu\",\"retries\":2,\"timeout\":1715100123336401403}}",
    "receiver": "cosmos1vlw72wh7rvl2vg4w434a6h9mftsl5vfqxvzvhs",
    "sender": "osmo1vlw72wh7rvl2vg4w434a6h9mftsl5vfqwh3upz",
    "source_channel": "channel-0",
    "source_port": "transfer",
    "timeout_height": {},
    "timeout_timestamp": "1715100123336399360",
    "token": {
      "amount": "99300",
      "denom": "ibc/27394FB092D2ECCD56123C74F36E4C1F926001CEADA9CA97EA622B25F41E5EB2"
    }
  }
}
```

Osmosis transaction memo:

```json
{
  "forward": {
    "channel": "channel-569",
    "next": {
      "wasm": {
        "contract": "neutron15lp29w5vtntsgecwxp5qx0m7tka6km885pcls4e4ule6yz6dhvqstukrvu",
        "msg": {
          "bond": {
            "receiver": "neutron1vlw72wh7rvl2vg4w434a6h9mftsl5vfqzntwdh"
          }
        }
      }
    },
    "port": "transfer",
    "receiver": "neutron15lp29w5vtntsgecwxp5qx0m7tka6km885pcls4e4ule6yz6dhvqstukrvu",
    "retries": 2,
    "timeout": 1715100123336401400
  }
}
```

As you can see, staking from Osmosis besides `ibc-hook` module requires using of [pfm](https://github.com/cosmos/ibc-apps/tree/main/middleware/packet-forward-middleware), because ATOM should be transferred to Cosmos Hub first and only after that to Neutron.

### Direct usage via SkipAPI

> SkipAPI integration is work in progress yet and will be available shortly after the launch

Instead of manually guiding SkipAPI on how to handle the ASSET (e.g., send to Neutron and stake), simply specify the desired result and let SkipAPI decide on the proper way to convert the assets. This approach is flexible but might have the potential caveat of the dASSET being bought on a DEX instead of being staked.

## Queries

### Instance contracts discovery

The `factory` contract returns all the other smart contract for a specific instance with the following query:

```json
{
  "state": {}
}
```

Query result example:

```json
{
  "core_contract": "neutron1elxhch2kul3qk2whxawtfwe0l2ma0snec3fe6j4zp2wftwrhs33q2yzqwy",
  "distribution_contract": "neutron1jnre6ef6mlcyfqsu8e9a2wf27farphsrgezlv0n8ezl9vfzdc7vqkmtvpm",
  "puppeteer_contract": "neutron1zvk70rw9xk5nvkw3c8ms62n5v9t6zpayfkygn8m5pgwyrqzsjsaq2upegw",
  "rewards_manager_contract": "neutron1t0spq2jeef7jvvydlaz4jxga37skrnqk0uuxa5d7nqcrjtnk79lsnfygj3",
  "staker_contract": "neutron1qcz9uw5g3vwqmz7qcsmcua3vzps6amrsqrmf7r84xfe76g3ztsrqm82sfy",
  "strategy_contract": "neutron1sjeppcavzvect0e5654tl4w06pp9sdx2pmxqy8m4jwv58jlwwv8quv86yy",
  "token_contract": "neutron1wgtjgeprg53wthczzlzpg0vrytuvfl9j59lpf87qd3mtj2dq6xysxvwcxd",
  "validators_set_contract": "neutron1sq87ct42mza6sjpj9qgkfk3ngyaqc03ykf78z3e5hez68zfs4a5qyxl5pg",
  "withdrawal_manager_contract": "neutron1tgw3d229d93rhk3hv68ff7f8zjs9lgk9lv9pkvp8fmt46ja47u0s02xxhg",
  "withdrawal_voucher_contract": "neutron1hvr35t4s0r9nrt4taujyu704r4wfynp4ed5dz32pa7xcwzgwr9vs7vu4gy"
}
```

Getting contracts with the TS client:

```tsx
const wallet = await DirectSecp256k1HdWallet.fromMnemonic("Mnemonic", {
  prefix: "neutron",
});
const client = await SigningCosmWasmClient.connectWithSigner(
  "https://rpc-palvus.pion-1.ntrn.tech:443",
  wallet,
  {
    gasPrice: GasPrice.fromString("0.025untrn"),
  }
);
const factoryContractClient = new DropFactory.Client(
  client,
  "neutron15lp29w5vtntsgecwxp5qx0m7tka6km885pcls4e4ule6yz6dhvqstukrvu"
);
const res = await factoryContractClient.queryState();
console.log(res);
```

### dASSET denom

The denom is stored in the `token` contract's config which can be obtained with the following query:

```json
{
  "config": {}
}
```

Query result example:

```json
{
  "core_address": "neutron1elxhch2kul3qk2whxawtfwe0l2ma0snec3fe6j4zp2wftwrhs33q2yzqwy",
  "denom": "factory/neutron1wgtjgeprg53wthczzlzpg0vrytuvfl9j59lpf87qd3mtj2dq6xysxvwcxd/drop"
}
```

### dASSET balance

Since dASSET is a native denom, you can get the dASSET balance by querying the bank module.

### Exchange rate

Exchange rate tells how many ASSET tokens correspond to single dASSET token. Thus, while Drop protocol auto-compounds staking rewards, this number is growing with time (it can possibly decrease because of slashing events).

Exchange rate is queried from the `core` contract with the following query:

```json
{
  "exchange_rate": {}
}
```

The output is a float number represented as a **string**.

Example of using the client code:

```tsx
const exchangeRate = parseFloat(await coreContractClient.queryExchangeRate());
```

### Withdrawal NFT info

Withdrawal NFT represents the promise to return the user ASSET tokens once unbonding period is over.
The user receives an NFT once they provide dASSET to unstake.

Here's the example on how to get the withdrawal NFT info from via generated client:

```tsx
const vouchers = await withdrawalVoucherContractClient.queryTokens({
  owner: neutronUserAddress,
});
```

## Actions

Any action is represented as exchanging one token for another:

- Staking is an exchange of ASSET for dASSET.
- Unstaking request is an exchange of dASSET for withdrawal NFT.
- Unstaking withdrawal is an exchange of withdrawal NFT for ASSET.

> NB: there is a planned plug in integration which will allow to skip the withdrawal step.
> The idea behind it that the user can provide an additional gas token and lock their withdrawal NFT in the special contract that will process the withdrawal for them automatically.
> So in the future it will be possible to unstake without the need to withdraw assets manually.

### Staking

Staking with Drop is done by the following message to the `core` contract **with assets to stake attached**, it is possible to omit `receiver` field, in this case sender's address will be used:

```json
{
  "bond": {
    "receiver": "neutron1receiveraddress"
  }
}
```

For specifying the staking referral see [Referral program integration](integrations/referral)

Example of using the TS client:

```tsx
const bondTxResult = await coreContractClient.bond(
  neutronUserAddress,
  {},
  1.6,
  undefined,
  [
    {
      amount: "500000",
      denom: neutronIBCDenom,
    },
  ]
);
```

### Unstaking request

To make an unstaking request, user should send the dASSET to the core contract with the following message:

```json
{
  "unbond": {}
}
```

Example of using the TS client:

```tsx
let unBondTxResult = await coreContractClient.unbond(
  neutronUserAddress,
  1.6,
  undefined,
  [
    {
      amount: Math.floor(200_000 / exchangeRate).toString(),
      denom: "token_factory_denom",
    },
  ]
);
```

After that, user receives a withdrawal voucher that they can use to withdraw their coins after the unbonding period.

### Withdrawal

Withdrawal of the ASSET implies sending the NFT to `withdrawal_manager` with the following message attached:

```json
{
  "withdraw": {}
}
```

Example of using the TS client:

```tsx
const voucherWithdrawTxResult = await voucherContractClient.sendNft(
  neutronUserAddress,
  {
    token_id: tokenId,
    contract: withdrawalManagerContractAddress,
    msg: Buffer.from(
      JSON.stringify({
        withdraw: {},
      })
    ).toString("base64"),
  }
);
```

### LSM Share Bond

> At the moment of writing, LSM is only available on Cosmos Hub.

Liquidity Staking Module (LSM) allows users to transfer their staked assets from one address to another without unstaking them. To learn more about it, visit the repository: https://github.com/iqlusioninc/liquidity-staking-module.

To achieve that, LSM mints special tokens that represent staked assets ownership. One can "tokenize" their staked assets and by sending them transfer an ownership to other user or protocol. These tokens are called "LSM shares" for simplicity.

Each LSM share is represented by a unique denom. It means that one can send a half of the share to someone but two different shares aren't fungible with each other.

Drop can accept such shares and mint dASSET based on them. I.e., if one has already natively staked tokens (delegated to a validator), they can tokenize their shares, IBC transfer them to Neutron and "stake" with Drop the same way as ASSET itself.

#### Message for tokenized share creation:

```json
{
  "@type": "/cosmos.staking.v1beta1.MsgTokenizeShares",
  "delegator_address": "cosmos_delegator_address",
  "validator_address": "cosmosvaloper_validator_address_to_whom_you_staked",
  "amount": {
    "denom": "denom",
    "amount": "1234"
  },
  "tokenized_share_owner": "cosmos_tokenized_share_owner"
}
```

In order to reveal how many tokens you staked with validators from certain delegator use [this](https://cosmos-lcd.quickapi.com/swagger/#/Query/DelegatorDelegations) query.

Also, please notice, that `validator_address` to whom you want delegate your tokens should be taken from our _white list_. To get this white list you need to query it from validators_set_contract. You can take it's address from core contract `config` query. In order to get validator set from given contract you need to query `validators` method.

#### To do IBC transfer to neutron:

```json
{
  "@type": "/ibc.applications.transfer.v1.MsgTransfer",
  "source_port": "transfer",
  "source_channel": "channel-123",
  "token": {
    "denom": "cosmosvaloper1**************************************/123",
    "amount": "1234"
  },
  "sender": "cosmos1_sender",
  "receiver": "neutron1_receiver",
  "timeout_height": "0",
  "timeout_timestamp": "12345",
  "memo": ""
}
```

In order to reveal:

- `source_channel` you can use "relayers" [page](https://www.mintscan.io/cosmos/relayers) on mintscan
- `timeout_timestamp` you can use this js snippet (timeout for 10mins will be enough):
  ```js
  Math.floor(Date.now() / 1000) * 1e9 + 10 * 60 * 1e9;
  ```

#### To do stake share with drop:

LSM share staking process is the very same as [ASSET staking](#staking), but the coin attached to the message is an LSM share IBC-transferred to Neutron.

Example of using the TS client:

```tsx
import { SigningStargateClient } from "@cosmjs/stargate";
import { MsgTransfer } from "cosmjs-types/ibc/applications/transfer/v1/tx";
import { AccountData, DirectSecp256k1HdWallet } from "@cosmjs/proto-signing";

const NeutronMainWallet = await DirectSecp256k1HdWallet.fromMnemonic(MNEMONIC, {
  prefix: "neutron",
});

const CosmosHubMainWallet = await DirectSecp256k1HdWallet.fromMnemonic(
  MNEMONIC,
  {
    prefix: "cosmos",
  }
);

const NeutronMainAccounts: readonly Array<AccountData> =
  await NeutronMainWallet.getAccounts();

const CosmosHubMainAccounts: readonly Array<AccountData> =
  await CosmosHubMainWallet.getAccounts();

const Cosmos_IBC_Sender = await SigningStargateClient.connectWithSigner(
  NODE_ADDRESS,
  CosmosHubMainWallet,
  {
    registry: new Registry(
      new Map<string, GeneratedType>([
        ["/ibc.applications.transfer.v1.MsgTransfer", MsgTransfer],
      ])
    ),
  }
);

// Do IBC transfer here
await Cosmos_IBC_Sender.signAndBroadcastSync(
  CosmosHubMainAccounts[0].address,
  [
    {
      typeUrl: "/ibc.applications.transfer.v1.MsgTransfer",
      value: {
        sourcePort: "transfer",
        sourceChannel: "channel-3457",
        token: {
          denom: "cosmosvaloper1********************************/******",
          amount: "1234",
        },
        sender: CosmosHubMainAccounts[0].address,
        receiver: NeutronMainAccounts[0].address,
        timeoutHeight: "0",
        timeoutTimestamp: String(
          Math.floor(Date.now() / 1000) * 1e9 + 10 * 60 * 1e9
        ),
      },
    },
  ],
  {
    gas: "400000",
    amount: [
      {
        denom: "uatom",
        amount: "4000",
      },
    ],
  },
  ""
);

// Execute `bond` with LSM shares
const bondTxResult = await coreContractClient.bond(
  neutronUserAddress,
  {},
  1.6,
  undefined,
  [
    {
      amount: "1234",
      denom: "ibc/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
    },
  ]
);
```
